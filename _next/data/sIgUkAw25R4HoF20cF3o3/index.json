{"pageProps":{"postsMetaData":[{"metadata":{"title":"Color Science for Image Processing","description":"Understand the concept of Color for Image Processing.","imgName":"color-science/color-science.jpg","date":"Aug 28, 2021","tags":["image-processing"],"keywords":["image-processing","computer-vision","color","opencv","digital-image-processing"],"id":"color-science-for-image-processing"},"content":"\n![Color Science for Image Processing](color-science/color-science.jpg)\n\n# Color Science for Image Processing\n\nEverything we deal with in image processing is all about colors. Digital image processing/signaling is about understanding and processing image data in the form of color bits that we encounter in our daily life. \n\nFrom Space exploration to Film making, Air force to Archeology, image processing is applied everywhere that uses colors to gather data. For example Hubble telescope uses image processing techniques like **broad-band** and **narrow-band** filtering to color map planets, nebula, and galaxies based on the gases and their interactions like in \"The Pillars of Creation\".\n\n![Pillars of Creation:=:40:=:The Pillars of Creation (NASA)$$$https://www.nasa.gov/image-feature/the-pillars-of-creation](color-science/pillars-of-creation.jpg)\n\nIn this article, we discuss color and its properties which helps us to understand different image processing/computer vision techniques.\n\n---\n\n## Color and Human Vision\n\nWhen we talk about colors, colors are represented in a way human eyes perceive. Because different species see things in different colors, and they can also see what humans cannot see like Snakes and Bats can detect infrared radiation which humans couldn't. So we generally restrict colors to human vision.\n\nColor is an illusion that our brain creates when a light beam reflects off an object/emits from an object and reaches our eyes. When light strikes the surface of an object, some light will be absorbed and some will be reflected. That reflected light with different wavelengths reaches our eyes and we perceive them as different colors.\n\nIssac Newton described the color as a quality of light. And the light which is an electromagnetic wave is classified into different segments with certain frequencies and wavelength ranges. The visible light spectrum is the segment of the electromagnetic spectrum that human eyes can only perceive. The visible light wavelength range is ~380 to ~780 nanometers. By deflection of light through a prism, Newton assigned different colors to different wavelengths in the visible spectrum which we generally see when a rainbow appears (VIBGYOR).\n\n![Visible Spectrum:=:55:=:Visible Light Spectrum$$$https://en.wikipedia.org/wiki/Electromagnetic_radiation](color-science/visible-spectrum.jpg)\n\nThe retina in our eye is responsible for vision. The retina contains photoreceptor cells that convert light rays and send signals back to the brain through nerves and the brain intercepts these colors. Rods and Cones in the retina are two types of photoreceptors that are responsible for our vision in dark and bright conditions. Rods work at a low level of light and our vision is in grayscale. Rods don't provide any color vision. At night as there is a low level of light we can see the objects in combinations of white and black (grayscale). Cones work in bright light and provides color vision. \n\n![Retina:=:70:=:Light capture by Rods and Cones in Retina$$$https://www.xrite.com/blog/color-perception-part-3](color-science/retina-rods-cones.jpg)\n\n### RGB (primary color) cones\n\nIn the 1800s, Thomas Young stated that the human eye consists of three different types of color receptors more likely red, green, and blue, and mixing these colors create other colors.\n\nThere are three types of cones called short (S), medium (M), and long (L) which are sensitive to different wavelength ranges of spectral distribution and detect Blue, Green, and Red respectively.\n\n![Normalized Cone Responsivity:=:45:=:Normalized Responsivity$$$https://en.wikipedia.org/wiki/Cone_cell^^^ of S, M and L cones](color-science/normalized-cone-responsivity.jpg)\n\nThese S, M, and L cones detect Blue, Green, and Red colors respectively and other colors are perceived by overlapping of different stimulations of these cones. The brain then integrates these cone signals and detects millions of colors. For example, Yellow color is a proportion of Green and Red cones and no or less effect of Blue cone. These three colors RGB (Red, Green, Blue) are primary colors and any color can be produced with the combination of these primitive colors.\n\n![Retinal Response:=:40:=:Retinal Response$$$https://askabiologist.asu.edu/rods-and-cones^^^ of rods and cones](color-science/retinal-response.jpg)\n\nIf we mix all RGB colors at a high-intensity level we get White color, and if RGB colors with 0 intensity level produce Black Color.\n\n### The Color of an object\n\nWhen a light beam hits the surface of an object, it absorbs some wavelengths and reflects a particular wavelength of light. An object looking Pink absorbs all wavelengths of light except some portion of Red and Blue. And our eyes receive those Red and Blue colors by cones and intercept as pink by stimulating the Red and Blue cones. Paints on walls are made to absorb all of the wavelengths except the color of their appearance. \n\n### Secondary colors\n\nIf we mix two primary colors at equal intensities and another one is being kept at a 0 level, we get secondary colors.\n- Cyan (Blue + Green)\n- Magenta (Red + Blue)\n- Yellow (Green + Red). \n\nThese Cyan (C), Magenta (M), and Yellow (Y) colors are called secondary colors (CMY) as they are derived from primary ones (RGB).\n\nC,M, and Y are also complementary colors to R, G, and B as synthensize of C, M and Y don't have any R, G, and B colors respectively. This means when an object is illuminated with RGB colors, the object absorbs at least one primary color and reflects the other two primary colors. An object looking Cyan would absorb Red but reflects Green and Blue (G + B = C). Mixing secondary colors produces RGB colors.\n- M + Y = R\n- Y + C = G\n- C + M = B\n\n### Additive and Subtractive Color System\n\nThe object appears in different colors if the various amount of RGB light emitted from it. It appears black when no percentage of RGB is emitted and if all are emitted at the highest intensity, it appears as white. Thus adding different RGB percentages produce different colors. This process of synthesizing colors by emitting RGB colors from black (when no light is produced) is called **Additive** color model. We start from black and reach white. Display monitors and screens we see around are based on an Additive color model. They produce colors by varying RGB color intensities.\n\nWhat if an object instead of emitting it reflects certain wavelengths of light by absorbing other wavelengths. This is how we naturally see an object and its appearance. An object absorbs some light and reflects other visible spectrum wavelengths that are perceived as color by our eyes. If an object absorbs cyan color, then it reflects red. Because \n$$\n\\small{White - Cyan = (R + G + B) - (G + B) = R}\n$$\nif we subtract cyan from white it produces a red color. \n\n![Additive and Subtractive Colors:=:40](color-science/additive-subtractive-colors.jpeg)\n\nHere subtracting means mixing colors as an object absorbs colors and then reflects. Thus mixing CMY colors with a white color produces different colors. This process of synthesizing colors from adding CMY mixtures to white is called **Subtractive** color model. We start from white to black color. Printing and painting involve this color synthesis to generate different colors on white paper or canvas. As mixing of CMY at the highest intensity produces brown color, printers also use black (K) color to generate shades of the black, and the resultant color group is called as CMYK color model.\n\n---\n\n## Color matching\n\nColor matching is representing and reproducing any color wavelength using primary monochromatic wavelengths. Using different intensities of primary colors, the target color wavelength is produced.\n\n### Grassman's laws of additive color mixture\n\nIn 1953, Grassmann recognized that any color can be matched with a linear combination of three primary colors. Grassmann's laws describe the relations between primary colors to match any color by additive color mixture. The following Grassmann's laws are fundamental for color mixing,\n\n- If two colors (X and Y) are the same, then mixing X and Y with the third color Z would still look like same. \n$$\n\\footnotesize{If \\space X = Y, \\space then \\space X + Z = Y + Z}\n$$\n\n- Any color C can be produced by a linear combination of three primary colors but no primary color is matched by a combination of the other two. \n$$\n\\footnotesize{C = xX + yY + zZ}\n$$\nwhere (x, y, z) are portions of primary colors (X, Y, Z) required to match color C.\n\n- Two colors C1 and C2, if mixed to form another color C3, then C3 can be matched by a linear combination of mixtures of primary colors that are used to produce C1 and color C3. \n$$\n\\footnotesize{C3 = C1 + C2 = (xX1 + yY1 + zZ1) + (xX2 + yY2 + zZ2)}\n$$\n\n- Colors that are produced by mixing primary colors have constant luminance. This is not true at various lighting conditions like in photopic (daylight) vision, objects appear in different colors, but in scotopic (night) vision, objects appear in grayscale.\n\n\n### Human tristimulus response\n\nIn the 1860s, James Maxwell stated that using RGB primary colors, all other colors can be generated but it is not possible to generate all colors only by addition and requires subtraction also to match certain colors. This is called the human tristimulus response. \n\n### 2&deg Standard Observer color-matching experiment\n\nIn the late 1920s, based on the works of Newton, Grassmann, and Maxwell, David Wright and John Guild independently conducted experiments to quantify the color reception ability of a normal human observer. They believed that human color receptors are located within the 2&deg arc of the fovea back from the retina, and asked standard observers or human volunteers to look through a hole that provides a 2&deg field of view. They asked volunteers to match the target color by adjusting combinations of red, blue, and green colors.\n\nAs not all colors could be matching using an additive color model of red, blue, and green, the target color is mixed with some portion of the primary color, and the other two primary colors are altered in portions to match the target colors.\n\nThe Commission International de l’Eclairage (CIE), based on Wright-Guild's 2&deg standard observer data, published RGB color matching functions to represent colors as a combination of three primary colors. This is also called **CIE standard 2&deg observer**.\n\n![2&deg and 10&deg Standard Observer:=:40:=:2&deg and 10&deg standard observer view$$$https://support.hunterlab.com/hc/en-us/articles/203420099-CIE-Standard-Observers-and-calculation-of-CIE-X-Y-Z-color-values-AN-1002b](color-science/standard-observer.jpg)\n\n### 10&deg Supplementary Standard Observer color-matching experiment\n\nIn the 1960s, researchers observed that cones present in the retina cover a larger field than the standard 2&deg view. Three researchers, Stiles, Burch, and Speranskaya again repeated color matching experiments with a 10&deg field view. They believed 10&deg color matching experiments would cover more spectral response than 2&deg. And it was right. In 1964, the CIE published 10&deg Standard Observer based on a 10&deg color-matching experiment. The 10&deg standard observer is recommended than 2&deg as it covers larger color representatives.\n\n## CIE 1924 $\\small{V(\\lambda)}$ Spectral Luminous Efficiency function\n\nHuman eyes perceive different wavelengths of visible spectrum at different brightness levles for same radiance energy. Sensitivity is zero at either end of the spectrum thus we recieve 0 brightness and no color.\n\nThe luminous efficiency function describes the human eye's sensitivity for different wavelengths. The more sensitivity observed the more brightness the color is. Eyes are most sensitive at **555nm** at daylight (photopic) and **507nm** at night (scotopic). CIE $\\small{V(\\lambda)}$ luminosity curve tells the relative sensitivity of the human eye for different color wavelengths. The luminous efficiency function distinguishes the brightness level of two colors at equal luminous. We can derive relative brightness for different colors with $\\small{V(\\lambda)}$ function.\n\n![Luminous efficiency function:=:50:=:Photopic (black) and Scotopic (green) luminosity function$$$https://en.wikipedia.org/wiki/Luminous_efficiencG_function](color-science/luminosity-curve.jpg)\n\nFrom $\\small{V(\\lambda)}$ luminous efficiency function, we can observe that, for equal radiance energy, brightness order of RGB is **green>red>blue**. For two colors at **500nm** and **570nm** to look as equal brightness, the color at **500nm** should be more luminous than **570nm**. \n$\\small{V(\\lambda)}$ function is an approximation function and accurate in some cases (like color blind people).\n\n### Relative luminance of RGB primaries\n\nThe above CIE RGB color matching functions are scaled in assumtion that all colors have same brightness. The $\\bar{r}$, $\\bar{g}$ and $\\bar{b}$ are normalized to have equal area under curve to yield $\\bar{r}(\\lambda) = \\bar{g}(\\lambda) = \\bar{b}(\\lambda) = 1$. The integrated area is assumed to be same that\n$$\n\\int \\bar{r}(\\lambda)d\\lambda = \\int \\bar{g}(\\lambda)d\\lambda = \\int \\bar{b}(\\lambda)d\\lambda = \\int V(\\lambda)d\\lambda\n$$\n\nSolving the above expression gives the relative luminanace ratios for **r : g : b = 1 : 4.5907 : 0.0601**. If we compare $V(\\lambda)$ luminous curve for **R = 700nm**, **G = 546.1nm** and **G = 435.8nm**, (r, g, b) luminance ratios are approximately matches.\n\nIf ratios are normalized such that sum of ratios equals to 1, then **r : g : b = 0.2126 : 0.7152 : 0.0722**.\n\nTo match any target color, RGB colors are mixed in portions obtained from CIE RGB color-mathcing function, and then those resultant RGB values should multiply by relative luminance ratios to get the target color with exact brightness.\n\n## CIE 1931 RGB color matching functions\n\nThe **Color matching functions** are mathematical estimation of color response of each primary color relative to human observer in 2&deg view field. Color matching functions gives amount of primary color energy required to generate target color wavelength. CIE defined three color mathcing functions $\\small{\\bar{r}(\\lambda), \\space \\bar{g}(\\lambda) \\space and \\space \\bar{b}(\\lambda)}$ which are normalized weight factors.\n\n![CIE 1931 RGB color matching functions:=:50](color-science/cie-rgb-cmf.jpg)\n\nIn the above RGB cmf diagram, each color wave represents RGB spectral intensities at various wavelengths. The three primary colors have peak sensitivity at wavelengths **R = 700nm**, **G = 546.1nm** and **G = 435.8nm**. The distribution of spectral energy is normalized and adding all color matching functions equals 1. Negative values in the graph indicate primary colors have to be mixed with the target color before color matching. And $\\small{\\bar{r}(\\lambda)}$ slightly matches the $\\small{V(\\lambda)}$ luminous efficiency function.\n\n### RGB Tristimulus values\n\nThe **tristimulus values** are, in a color space, the amount of color proportions of primary colors are required in a tri-chromatic additive color model to produce a color.\n\nFor CIE 1931 RGB color space, the RGB tristimulus values for spectral distribution of color $\\small{S(\\lambda)}$ can be calculated as\n$$\n\\small{R = \\int S(\\lambda)\\bar{r}(\\lambda)d\\lambda \\hspace2ex\nG = \\int S(\\lambda)\\bar{g}(\\lambda)d\\lambda \\hspace2ex\nB = \\int S(\\lambda)\\bar{b}(\\lambda)d\\lambda}\n$$\n\nwhere $\\small{S(\\lambda)}$ is spectral intensity of a color.\n\nIt can also be expressed as, for a color $\\small{C}$,\n$$\n\\small{C = R\\bar{r}(\\lambda) + G\\bar{g}(\\lambda) + B\\bar{b}(\\lambda)}\n$$\n$$\n\\small{C = R\\bold{R} + G\\bold{G} + B\\bold{B}}\n$$\n\nwhere $\\small{R}$, $\\small{G}$ and $\\small{B}$ are tristimulus values, and scaled to unit length.\n\n## CIE XYZ color matching functions\n\nRGB color matching functions contain negative intensities in mathematical form but they are not practically suitable for the physical world. CIE then converted RGB color space to XYZ color space where XYZ are linear combinations of monochromatic colors RGB. The new XYZ color matching functions have only positive intensities. The derived XYZ parameters are imaginary and they roughly represent S, M, and L cones.\n\n![CIE XYZ color matching functions:=:60](color-science/cie-xyz-cmf.jpg)\n\n$\\small{\\bar{x}(\\lambda), \\bar{y}(\\lambda) \\space and \\space \\bar{z}(\\lambda)}$ are color matching functions. From above diagram, we can say Violet (around 450nm) color is a mixture of Red and Blue which is indeed true and this cannot be seen in RGB color matching function curves.\n\nAlso, distribution of $\\small{\\bar{y}(\\lambda)}$ is close to $\\small{V(\\lambda)}$ luminous efficiency function. So Y component also roughly describes the luminance of the color.\n\nXYZ is a linear combination of RGB colors. If RGB colors are vectors with unit length and act as vector basis, they form a three-dimensional vector space. And XYZ vectors form a new basis vector by a linear transformation **M** of RGB vector basis.\n\n$$\n\\small{\\begin{bmatrix}\nX \\\\\nY \\\\\nZ \\\\\n\\end{bmatrix} = M\n\\begin{bmatrix}\nR & G & B\n\\end{bmatrix}}\n$$\n$$\n\\small{\\begin{bmatrix}\nX \\\\\nY \\\\\nZ \\\\\n\\end{bmatrix} = \n\\begin{bmatrix}\nR_x & R_y & R_z \\\\\nG_x & G_y & G_z \\\\\nB_x & B_y & B_z\n\\end{bmatrix}\n\\begin{bmatrix}\nR & G & B\n\\end{bmatrix}}\n$$\n$$\n\\small{\\begin{bmatrix}\nX \\\\\nY \\\\\nZ \\\\\n\\end{bmatrix} = \\frac{1}{0.17}\n\\begin{bmatrix}\n0.49 & 0.31 & 0.20 \\\\\n0.17 & 0.81 & 0.01 \\\\\n0.00 & 0.01 & 0.99\n\\end{bmatrix}\n\\begin{bmatrix}\nR & G & B\n\\end{bmatrix}}\n$$\n\nwhere X, Y, and Z are tristimulus values defined as, for spectral color distribution $\\small{S(\\lambda)}$\n$$\n\\small{X = \\int S(\\lambda)\\bar{x}(\\lambda)d\\lambda \\hspace2ex\nY = \\int S(\\lambda)\\bar{y}(\\lambda)d\\lambda \\hspace2ex\nZ = \\int S(\\lambda)\\bar{z}(\\lambda)d\\lambda}\n$$\n\nFrom the above transformation matrix **M**, we can say Red and Green colors have zero or no impact on Z which can be confirmed from RGB color matching functions.\n\n---\n\n## CIE xy chromaticity diagram & CIE xyY color space\n\nImagine if XYZ tristimulus values are represented as unit scale vectors, they form a 3D vector space and contains all possible colors with RGB combinations in a cube. Now trace out the coordinates of XYZ for different wavelengths in the visible spectrum, the closed curve that is formed by joining all coordinates is called spectral locus.\n\n![CIE XYZ color space:=:60:=:CIE XYZ spectral locus$$$https://commons.wikimedia.org/wiki/File:3D_Graph_of_CIE_XYZ_Colorspace.png](color-science/cie-xyz-colorspace.jpg)\n\nThe above 3D XYZ color space contains colors with Hue, Saturationm and Intensity/Brightness. It requires three parameters (H, S, and V) to describe a color (each for hue, saturation, and intensity).\n\nIf (X, Y, Z) are projected to $\\small{X + Y + Z = 1}$ plane in XYZ vector space, then normalized representation of (X, Y, Z) is\n$$\n\\small{x = \\frac{X}{X + Y + Z} \\hspace2ex \ny = \\frac{Y}{X + Y + Z} \\hspace2ex\nz = \\frac{Z}{X + Y + Z}}\n$$\n\nsumming up the normalized x, y and z components equals to 1 i.e, $\\small{x + y + z = 1}$ and $\\small{x,y,z\\ge0}$\n\nThe planar projection of the above spectral locus to the plane $\\small{X + Y + Z = 1}$, then it forms a planar triangle.\n\n![CIE XYZ planar projection:=:35](color-science/spectral-locus-planar-projection.jpg)\n\n**Chromaticity** is a color property without intensity i.e color independent component of a color. Chromaticity is the quality of a color determined by its dominant wavelength and its purity (chroma/saturation). In chromaticity, only hue and saturation are used to describe the colors. That means light blue and dark blue have the same hue and saturation values, and same color matching functions.\n\nA chromaticity diagram is a representation of 3D XYZ color space in 2D space with only chromaticity values (hue and saturation). As $x + y + z =1$, any component can be derived from two other components. So z can be derived from x and y as\n$$\n\\small{x + y + z = 1}\n$$\n$$\n\\small{z = 1 - x - y}\n$$\n\nAny tristimulus value can be derived from other tristimulus values. With Y, X and Z are derived as \n$$\n\\small{X = \\frac{Y}{y}x}\n$$\n$$\n\\small{Z = \\frac{Y}{y}(1 - x - y)}\n$$\n\nIf the above spectral locus triangular plane in xyz-plane is projected onto xy-plane, a chromaticity diagram is obtained. And to construct the actual XYZ values, Y is stored along with xy. Together xyY forms the **CIE xyY** color space with xy as chromaticity coordinates and Y as a luminance value because we discussed earlier that the Y component roughly matches $\\small{V(\\lambda)}$.\n\nThe [RGB chromaticity diagram](https://en.wikipedia.org/wiki/Rg_chromaticity) could be constructed by following the same procedure as XYZ. Here **CIE rgG** color space is constructed by keeping rg chromaticity coordinates and G value for luminance.\n\n![CIE chromaticity diagram:=:50:=:CIE xyY chromaticity diagram](color-science/cie-chromaticity-diagram.jpg)\n\nThe horseshoe shape in the above diagram contains all colors of the projected planar triangle. The chromaticity diagram is a mathematical representation of the human eye's color perception. \n- The outer line of the spectral locus has colors with wavelengths distributed across in visible spectrum. Starting from violet to red and magenta line as a bridge between. These colors are hues or dominant wavelength colors which are seen in the rainbow.\n- The region inside the spectral locus contains all colors possible in XYZ space that are visible to our human eyes. These colors are saturated colors of hues or a mixture of monochromatic wavelengths.\n- A point (x, y) on the above graph matches a color in the xyY color space.\n- It can be observed that CMY (cyan, magenta, yellow) colors lie between (green and blue), (blue and red), and (red and green). CMY colors are present in complement/opposite to RGB.\n\n### Color gamut\n\n**Color gamut** describes a range of colors in the visible spectrum that are visible for human eyes. The color gamut of a device is that subset of color space that can be represented. color gamuts are generally a subset of the CIE chromaticity diagram with the center as a white point.\n\n![Color gamut:=:50:=:Different color gamuts in CIE xy chromaticity diagram$$$https://en.wikipedia.org/wiki/Gamut](color-science/color-gamut.jpg)\n\nColor gamuts are color spaces enclosed by a triangle with color coordinates of the monitor as red, green, and blue colors. A gamut is a three-dimensional color space with lightness being the third dimension perpendicular to the chromaticity diagram.\n\nCertain color gamuts are standardized by different institutions to reproduce the colors across different environments. The **sRGB** color gamut is the standard color subset used to display colors around the web.\n\nThe colors outside of the chromaticity diagram but inside a color gamut (like ProPhoto RGB) are called imaginary colors as they are not visible for human eyes and they look like normal visible colors. These colors can be detected using color measuring techniques but our eyes cannot differentiate those colors with normal visible colors.\n\n---\n\n### References\n- [How the CIE 1931 color matching functions were derived](https://silo.tips/download/how-the-cie-1931-color-matching-functions-were-derived-from-wright-guild-data)\n- https://scholar.harvard.edu/files/schwartz/files/lecture17-color.pdf\n- [CIE 1931 color space - Wikipedia](https://en.wikipedia.org/wiki/CIE_1931_color_space)\n- [CIE color space - Gernot Hoffmann](http://docs-hoffmann.de/ciexyz29082000.pdf)\n- https://engineering.purdue.edu/~bouman/ece637/notes/pdf/Tristimulus.pdf\n- http://graphics.stanford.edu/courses/cs148-10-summer/docs/02_light_color.pdf\n- http://cs.haifa.ac.il/hagit/courses/ist/Lectures/IST03_ColorXYZx4.pdf\n- http://www.cs.cmu.edu/afs/cs/academic/class/15462-s16/www/lec_slides/23_color.pdf\n- https://web.eecs.umich.edu/~sugih/courses/eecs487/lectures/22-Light+Color.pdf\n- [Light, Color and Color Space - Scratch Pixel](https://www.scratchapixel.com/lessons/digital-imaging/colors/color-space)\n- [Color Matching - Craig Blackwell](https://www.youtube.com/watch?v=82ItpxqPP4I)\n- [Visualizing the XYZ Color space](https://www.youtube.com/watch?v=x0-qoXOCOow)\n- [A Beginner's Guide to Colorimetry](https://medium.com/hipster-color-science/a-beginners-guide-to-colorimetry-401f1830b65a)\n- [Precise Color Communincation - Konica Minolta](https://www.konicaminolta.com/instruments/knowledge/color/index.html)\n- [Color Gamut](https://epxx.co/artigos/gamut_en.html)"},{"metadata":{"title":"Create a Notes App with Flutter","description":"Create a color-rich Note-taking app with Flutter.","imgName":"note-app-flutter/note-app-in-flutter.jpg","date":"Jun 15, 2021","tags":["flutter"],"keywords":["flutter","dart","android","note-app","note-taking","sqflite","sqlite"],"id":"create-a-notes-app-with-flutter"},"content":"\n![Create a Notes App with flutter](note-app-flutter/note-app-in-flutter.jpg)\n\n# Create a Note-taking App in Flutter\n\nFlutter is a declarative framework that requires programming in Dart. Flutter is suitable for creating simple apps like Note-taking, Event-registration, etc.\n\n> Pre-requisites: Knowledge of basic Dart and Flutter. Read about [Flutter](https://flutter.dev/docs) and [Dart](https://dart.dev/guides).\n\nWith basic concepts like Widgets and Material design we can create simple apps very fast and easily in Flutter as in Flutter we can use tons of pre-designed widgets to create almost every popular design using in the modern design world.\n\nIn this tutorial, we discuss creating a simple note-taking app. The note-taking app we are going to create provides options like create, save, update and delete notes. \n\nOur note-taking app contains two screens \n- Home screen to display all saved notes\n- Notes edit screen to create new notes or edit saved notes\n\n## Create Flutter App\n\nBefore creating a Flutter app please make sure you have installed flutter-sdk and dart-sdk. If not follow the instructions to [install flutter](https://flutter.dev/docs/get-started/install).\n\nCreate a raw flutter app from the terminal. Run the following command and pass any name (to join more than single sting use only underscore)\n\n```bash\nflutter create notes_app\n```\n\nGo to root directory of **notes_app** and locate **main.dart** in **lib** folder. This is where our app starts execution by calling the main() function. You can find some code here which displays the welcome screen.\n\nNow to see the app in an emulator or on a physical device run the below command.\n\n```bash\ncd notes_app/\nflutter run\n```\n\nFor the initial run, it takes some time to install the app on the device, and later builds will be fast. If you encounter any error run _flutter doctor -v_ for additional information and make sure all necessary items are checked.\n\n---\n\n## What a Note should like and contain?\n\nA simple note must have a title and the content which can be edited as many times as possible. We can also add color to note for look and feel. \n\nTo store notes we use [Sqflite](https://pub.dev/packages/sqflite) (a plugin to mimic SQL database in Flutter). Each note can be stored as a single row in the database with fields id, title, content, color. \n\nCreate a file **note.dart** inside **lib/models**. Add a class **Note** to store note as an object which can be converted later as a Map object to store in the database.\n\n```dart:models/note.dart\nclass Note {\n\tint id;\n\tString title;\n\tString content;\n\tString noteColor;\n\n\tNote({\n\t\tthis.id = null, \n\t\tthis.title = \"Note\", \n\t\tthis.content = \"Text\", \n\t\tthis.noteColor = 'red'\n\t});\n\n\tMap<String, dynamic> toMap() {\n\t\tMap<String, dynamic> data = Map<String, dynamic>();\n\t\tif (id != null) {\n\t\t\tdata['id'] = id;\n\t\t}\n\t\tdata['title'] = title;\n\t\tdata['content'] = content;\n\t\tdata['noteColor'] = noteColor;\n\t\treturn data;\n\t}\n\n\t@override toString() {\n\t\treturn {\n\t\t\t'id': id,\n\t\t\t'title': title,\n\t\t\t'content': content,\n\t\t\t'noteColor': noteColor,\n\t\t}.toString();\n\t}\n}\n```\n\nThis Note class has attributes\n- id (primary key) - an identifier to store unique note objects in the database\n- title - the title of the note\n- content - content of the note\n- noteColor - the color of the note\n\n**toMap()** returns note as an object to store in the database.\n\nFor note colors, add another file called **theme/note_colors.dart** inside **lib/theme**.\n```dart:theme/note_colors.dart\nconst NoteColors = {\n\t'red': {'l': 0xFFFFCDD2,'b': 0xFFE57373},\n\t'pink': {'l': 0xFFF8BBD0, 'b': 0xFFF06292},\n\t'purple': {'l': 0xFFE1BEE7, 'b': 0xFFBA68C8},\n\t'deepPurple': {'l': 0xFFD1C4E9, 'b': 0xFF9575CD},\n\t'indigo': {'l': 0xFFC5CAE9, 'b': 0xFF7986CB},\n\t'blue': {'l': 0xFFBBDEFB, 'b': 0xFF64B5F6},\n\t'lightBlue': {'l': 0xFFB3E5FC, 'b': 0xFF4FC3F7},\n\t'cyan': {'l': 0xFFB2EBF2, 'b': 0xFF4DD0E1},\n\t'teal': {'l': 0xFFB2DFDB, 'b': 0xFF4DB6AC},\n\t'green': {'l': 0xFFC8E6C9, 'b': 0xFF81C784},\n\t'lightGreen': {'l': 0xFFDCEDC8, 'b': 0xFFAED581},\n\t'lime': {'l': 0xFFF0F4C3, 'b': 0xFFDCE775},\n\t'yellow': {'l': 0xFFFFF9C4, 'b': 0xFFFFF176},\n\t'amber': {'l': 0xFFFFECB3, 'b': 0xFFFFD54F},\n\t'orange': {'l': 0xFFFFE0B2, 'b': 0xFFFFB74D},\n\t'deepOrange': {'l': 0xFFFFCCBC, 'b': 0xFFFF8A65},\n\t'brown': {'l': 0xFFD7CCCB, 'b': 0xFFA1887F},\n\t'blueGray': {'l': 0xFFCFD8DC, 'b': 0xFF90A4AE},\n};\n```\n\nEach color name ('k') is a key and each key ('k') has two colors 'l' and 'b', where 'l' is a light color and 'b' is the bright color of this 'k' color. The light and bright colors are used to display a note in the UI which we discuss later. 'k' is the color name we store in the database.\n\n---\n\n## Store notes in the database\n\nNow to store notes on the database we use **sqflite** plugin. Install **sqflite** by adding dependency in *pubspec.yaml*.\n\n```bash\ndependencies:\n  flutter:\n    sdk: flutter\n  sqflite: ^1.3.0\n```\n\nNow in terminal run *flutter pub get* to install or update dependencies in *pubspec.yaml*.\n\nTo handle database operations we write different functions for different operations like read, write, update and delete. Create **notes_database.dart** inside **models** and add a class to handle different operations\n\n```dart:models/notes_database.dart\nimport 'package:sqflite/sqflite.dart';\n\nimport 'note.dart';\n\nclass NotesDatabase {\n\tstatic final _name = \"NotesDatabase.db\";\n\tstatic final _version = 1;\n\n\tDatabase database;\n\tstatic final tableName = 'notes';\n\n\tinitDatabase() async {\n\t\tdatabase = await openDatabase(\n\t\t\t_name,\n\t\t\tversion: _version,\n\t\t\tonCreate: (Database db, int version) async {\n\t\t\t\tawait db.execute(\n\t\t\t\t\t'''CREATE TABLE $tableName (\n\t\t\t\t\tid INTEGER PRIMARY KEY AUTOINCREMENT,\n\t\t\t\t\ttitle TEXT,\n\t\t\t\t\tcontent TEXT,\n\t\t\t\t\tnoteColor TEXT\n\t\t\t\t\t)'''\n\t\t\t\t);\n\t\t\t}\n\t\t);\n\t}\n\n\tFuture<int> insertNote(Note note) async {\n\t\treturn await database.insert(tableName, \n\t\t\tnote.toMap(), \n\t\t\tconflictAlgorithm: ConflictAlgorithm.replace\n\t\t);\n\t}\n\n\tFuture<int> updateNote(Note note) async {\n\t\treturn await database.update(tableName, note.toMap(),\n\t\t\twhere: 'id = ?', \n\t\t\twhereArgs: [note.id],\n\t\t\tconflictAlgorithm: ConflictAlgorithm.replace\n\t\t);\n\t}\n\n\tFuture<List<Map<String, dynamic>>> getAllNotes() async {\n\t\treturn await database.query(tableName);\n\t}\n\n\tFuture<Map<String, dynamic>> getNotes(int id) async {\n\t\tvar result = await database.query(tableName,\n\t\t\twhere: 'id = ?',\n\t\t\twhereArgs: [id]\n\t\t);\n\n\t\tif (result.length > 0) {\n\t\t\treturn result.first;\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tFuture<int> deleteNote(int id) async {\n\t\treturn await database.delete(tableName,\n\t\t\twhere: 'id = ?',\n\t\t\twhereArgs: [id]\n\t\t);\n\t}\n\n\tcloseDatabase() async {\n\t\tawait database.close();\n\t}\n}\n```\n\nFirst, we need to create a table in the database with some schema. Inside **initDatabase()**, we are calling **openDatabase()** to create database and table or open existing database and table by passing parameters **_name** (name of the database) and **_version** where **_name = NotesDatabse.db** is the name of the database and we can maintain different versions of the database through **_version**. \n\nIf there is no database with a specified **name**, **onCreate** callback is called to create a database with table and schema. Above we create a table with **tableName = notes** and initial schema with required fields like id, title, content, and noteColor to store a note object. \n\n**openDatabase()** is an async operation and returns **Database** object reference which points to the created/existed database. We store this reference as **database** of type class **Database**.\n\nOther functions **insertNote**, **updateNote**, **getNotes** and **deleteNotes** handles different database operations. Read more about [how to perform different operations in sqflite](https://github.com/tekartik/sqflite/blob/master/sqflite/doc/how_to.md).\n\nAs we cannot store Note as a class object we convert Note object members to a Map object by calling Note.toMap() which returns a Map object which sqflite map fields and values to store in the database. And Sqflite returns data as Map objects the way we pass it to insert rows in the database.\n\nWe have added logic to maintain notes in the database. But we have not done anything in UI to interact for maintaining notes. \n\n## Add Home Screen\n\nNow create a file called **home.dart** in **lib/screens**. This **home.dart** serves as the Home screen of our app. Add following code to **home.dart**\n\n```dart:screens/home.dart\nimport 'package:flutter/material.dart';\n\nconst c1 = 0xFFFDFFFC, c2 = 0xFFFF595E, c3 = 0xFF374B4A, c4 = 0xFF00B1CC, c5 = 0xFFFFD65C, c6 = 0xFFB9CACA,\n\tc7 = 0x80374B4A, c8 = 0x3300B1CC, c9 = 0xCCFF595E;\n\n// Home Screen\nclass Home extends StatefulWidget{\n\t@override\n\t_Home createState() => _Home();\n}\n\nclass _Home extends State<Home> {\n\t@override\n\tWidget build(BuildContext context) {\n\t\treturn MaterialApp(\n\t\t\ttitle: 'Super Note',\n\t\t\thome: Scaffold(\n\t\t\t\tbackgroundColor: Color(c6),\n\t\t\t\tappBar: AppBar(\n\t\t\t\t\tautomaticallyImplyLeading: false,\n\t\t\t\t\tbackgroundColor: const Color(c2),\n\t\t\t\t\tbrightness: Brightness.dark,\n\n\t\t\t\t\ttitle: Text(\n\t\t\t\t\t\t'Super Note',\n\t\t\t\t\t\tstyle: TextStyle(\n\t\t\t\t\t\t\tcolor: const Color(c5),\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t),\n\n\t\t\t\t//Floating Button\n\t\t\t\tfloatingActionButton: FloatingActionButton(\n\t\t\t\t\tchild: const Icon(\n\t\t\t\t\t\tIcons.add,\n\t\t\t\t\t\tcolor: const Color(c5),\n\t\t\t\t\t),\n\t\t\t\t\ttooltip: 'New Notes',\n\t\t\t\t\tbackgroundColor: const Color(c4),\n\t\t\t\t\tonPressed: () => {},\n\t\t\t\t),\n\t\t\t),\n\t\t);\n\t}\n}\n```\n\nThere are some color constants defined at the top which will be used across the app. The color format in Flutter is different from normal Hex. In normal Hex format, we provide opacity at last but in Flutter we have to provide opacity at first.\n\nHere we are creating a Home widget as **StatefulWidget** keeping in mind that we need to maintain the state. Every custom widget must override **build** method and return a widget. **MaterialApp** widget gives child widgets material look and we must declare required attributes. **Scaffold** widget is a common material design concept that provides appbar, floating button, drawer, body, etc.  \n\nThe Home screen displays all notes stored in the database. We discuss later displaying notes in the Home screen after creating notes in the Edit screen.\n\nTo display our Home screen as default screen in our app call **Home()** widget inside **MyApp** in **main.dart**\n\n```dart:main.dart\nimport 'package:flutter/material.dart';\n\nimport './screens/home.dart';\n\nvoid main() => runApp(MyApp());\n\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Home(),\n    );\n  }\n}\n```\n\nTo see the changes in the app, in the flutter running environment press **r** to hot reload or **R** restart of the app.\n\n![Home Screen:=:30](note-app-flutter/notes-app-initial-home-screen.jpg)\n\nThe Floating action button at the bottom-right will take us to the Edit screen to create a new note. To add navigation from Home to Edit, first create a Edit Screen Widget in **notes_edit.dart** inside **lib/screens**. For now, add a simple UI for the Edit screen like below because we just need a widget to route from Home to Edit screen.\n\n```dart:screens/notes_edit.dart\nimport 'package:flutter/material.dart';\n\nconst c1 = 0xFFFDFFFC, c2 = 0xFFFF595E, c3 = 0xFF374B4A, c4 = 0xFF00B1CC, c5 = 0xFFFFD65C, c6 = 0xFFB9CACA,\n\t\t\tc7 = 0x80374B4A;\n\nclass NotesEdit extends StatefulWidget {\n\t_NotesEdit createState() => _NotesEdit();\n}\n\nclass _NotesEdit extends State<NotesEdit> {\n\t@override\n\tWidget build(BuildContext context) {\n\t\treturn MaterialApp(\n\t\t\ttitle: 'Edit Screen',\n\t\t\thome: Text(\n\t\t\t\t'Edit'\n\t\t\t),\n\t\t);\n\t}\n}\n```\n\n**NotesEdit** widget is the main widget for the Edit screen. We call this widget in navigation.\n\n### Navigation from Home to Edit\n\nAdd navigation from Home to Edit when pressed floating-action-buttton. Call **Navigation.push()** for the **EditNotes** widget. In **home.dart** add navigation in **onPressed()** event of floating-action-button.\n\n```dart\nimport './notes_edit.dart';\n```\n\n```dart\n//Floating Button\nfloatingActionButton: FloatingActionButton(\n\tchild: const Icon(\n\t\tIcons.add,\n\t\tcolor: const Color(c5),\n\t),\n\ttooltip: 'New Notes',\n\tbackgroundColor: const Color(c4),\n\t// Go to Edit screen\n\tonPressed: () {\n\t  Navigator.push(\n\t  \tcontext,     \n\t    MaterialPageRoute(builder: (context) => NotesEdit()),\n\t  );\n\t}\n),\n```\n\n---\n\n## Change Edit Screen\n\nChange Edit screen UI for creating a new note.\n\n```dart:screens/notes_edit.dart\nimport 'package:flutter/material.dart';\n\nimport '../models/note.dart';\nimport '../models/notes_database.dart';\nimport '../theme/note_colors.dart';\n\nconst c1 = 0xFFFDFFFC, c2 = 0xFFFF595E, c3 = 0xFF374B4A, c4 = 0xFF00B1CC, c5 = 0xFFFFD65C, c6 = 0xFFB9CACA,\n\tc7 = 0x80374B4A;\n\nclass NotesEdit extends StatefulWidget {\n\t_NotesEdit createState() => _NotesEdit();\n}\n\nclass _NotesEdit extends State<NotesEdit> {\n\tString noteTitle = '';\n\tString noteContent = '';\n\tString noteColor = 'red';\n\n\tTextEditingController _titleTextController = TextEditingController();\n\tTextEditingController _contentTextController = TextEditingController();\n\n\tvoid handleTitleTextChange() {\n\t\tsetState(() {\n\t\t\tnoteTitle = _titleTextController.text.trim();\n\t\t});\n\t}\n\n\tvoid handleNoteTextChange() {\n\t\tsetState(() {\n\t\t\tnoteContent = _contentTextController.text.trim();\n\t\t});\n\t}\n\n\t@override\n\tvoid initState() {\n\t\tsuper.initState();\n\t\t_titleTextController.addListener(handleTitleTextChange);\n\t\t_contentTextController.addListener(handleNoteTextChange);\n\t}\n\n\t@override\n\tvoid dispose() {\n\t\t_titleTextController.dispose();\n\t\t_contentTextController.dispose();\n\t\tsuper.dispose();\n\t}\n\n\t@override\n\tWidget build(BuildContext context) {\n\t\treturn Scaffold(\n\t\t\tbackgroundColor: Color(NoteColors[this.noteColor]['l']),\n\t\t\tappBar: AppBar(\n\t\t\t\tbackgroundColor: Color(NoteColors[this.noteColor]['b']),\n\n\t\t\t\tleading: IconButton(\n\t\t\t\t\ticon: const Icon(\n\t\t\t\t\t\tIcons.arrow_back,\n\t\t\t\t\t\tcolor: const Color(c1),\n\t\t\t\t\t),\n\t\t\t\t\ttooltip: 'Back',\n\t\t\t\t\tonPressed: () => {},\n\t\t\t\t),\n\n\t\t\t\ttitle: NoteTitleEntry(_titleTextController),\n\t\t\t),\n\n\t\t\tbody: NoteEntry(_contentTextController),\n\t\t);\n\t}\n}\n```\n\nIn the above **NotesEdit** widget, the state variables **noteTitle**, **noteContent** and **noteColor** are initialized to default values for now. **noteTitel** is to store title of the note, **noteContent** is to store note content and**noteColor** is color of the color, light and bright colors of the **noteColor** are used as **backgroundColor** for **appBar** and **Scaffold** respectively. \n\nAlso there are two **TextEditingController** defined which are used to controll **TextField** values for **noteTitle** and **noteContent**. These two text controller are attached with listeners in **iniitState()**. These listeneres listen to changes and updates text values in state. **_titleTextController** handles and updates text value for **noteTitle** and **_contentTextController** handles **noteContent**.\n\nThe **title** of the **appBar** is set to a widget **NoteTitleEntry** which handles displaying and editing of the title.\n\n```dart\nclass NoteTitleEntry extends StatelessWidget {\n\tfinal _textFieldController;\n\n\tNoteTitleEntry(this._textFieldController);\n\n\t@override\n\tWidget build(BuildContext context) {\n\t\treturn TextField(\n\t\t\tcontroller: _textFieldController,\n\t\t\tdecoration: InputDecoration(\n\t\t\t\tborder: InputBorder.none,\n\t\t\t\tfocusedBorder: InputBorder.none,\n\t\t\t\tenabledBorder: InputBorder.none,\n\t\t\t\terrorBorder: InputBorder.none,\n\t\t\t\tdisabledBorder: InputBorder.none,\n\t\t\t\tcontentPadding: EdgeInsets.all(0),\n\t\t\t\tcounter: null,\n\t\t\t\tcounterText: \"\",\n\t\t\t\thintText: 'Title',\n\t\t\t\thintStyle: TextStyle(\n\t\t\t\t\tfontSize: 21,\n\t\t\t\t\tfontWeight: FontWeight.bold,\n\t\t\t\t\theight: 1.5,\n\t\t\t\t),\n\t\t\t),\n\t\t\tmaxLength: 31,\n\t\t\tmaxLines: 1,\n\t\t\tstyle: TextStyle(\n\t\t\t\tfontSize: 21,\n\t\t\t\tfontWeight: FontWeight.bold,\n\t\t\t\theight: 1.5,\n\t\t\t\tcolor: Color(c1),\n\t\t\t),\n\t\t\ttextCapitalization: TextCapitalization.words,\n\t\t);\n\t}\t\n}\n```\n\nIn the **TextField**, the controller is set to **_textFieldController** which is passed from parent widget ** as **_titleTextController**. \n\nSimilarly, content of the notes is handled by another widget **NoteEntry**.\n\n```dart\nclass NoteEntry extends StatelessWidget {\n\tfinal _textFieldController;\n\n\tNoteEntry(this._textFieldController);\n\n\t@override\n\tWidget build(BuildContext context) {\n\t\treturn Container(\n\t\t\theight: MediaQuery.of(context).size.height,\n\t\t\tpadding: EdgeInsets.symmetric(horizontal: 12, vertical: 8),\n\t\t\tchild: TextField(\n\t\t\t\tcontroller: _textFieldController,\n\t\t\t\tmaxLines: null,\n\t\t\t\ttextCapitalization: TextCapitalization.sentences,\n\t\t\t\tdecoration: null,\n\t\t\t\tstyle: TextStyle(\n\t\t\t\t\tfontSize: 19,\n\t\t\t\t\theight: 1.5,\n\t\t\t\t),\n\t\t\t),\n\t\t);\n\t}\n}\n```\n\nHere also controller of **TextField** is set to **_textFieldController** which is passed from parent wdiget as **_contentTextController**.\n\nAfter adding all these widgets, the Edit screen would look like\n\n![Edit screen:=:30](note-app-flutter/notes-app-initial-edit-screen.jpg)\n\n### Add a Color palette to select Note color\n\nWe will add a color palette to select note color and store the value in **noteColor**. For color palette, add an icon in **appBar** **actions** which on press shows a **Dialog** box with different colors.\n\nIn **NotesEdit** add color palette button\n\n```dart\nactions: [\n\tIconButton(\n\t\ticon: const Icon(\n\t\t\tIcons.color_lens,\n\t\t\tcolor: const Color(c1),\n\t\t),\n\t\ttooltip: 'Color Palette',\n\t\tonPressed: () => handleColor(context),\n\t),\n],\n```\n\nFor this button, **onPressed** event calls **handleColor()** function which shows a color palette and store selected value in **noteColor** variable. Define **handleColor()** inside **_NotesEdit**\n\n```dart\nvoid handleColor(currentContext) {\n\tshowDialog(\n\t\tcontext: currentContext,\n\t\tbuilder: (context) => ColorPalette(\n\t\t\tparentContext: currentContext,\n\t\t),\n\t).then((colorName) {\n\t\tif (colorName != null) {\n\t\t\tsetState(() {\n\t\t\t\tnoteColor = colorName;\n\t\t\t});\n\t\t}\n\t});\n}\n```\n\nThis **handleColor()** calls widget **ColorPalette** which is a **Dialog** box and returns selected color value. Add **ColorPalette** widget to show different colors and return selected color\n\n```dart\nclass ColorPalette extends StatelessWidget {\n\tfinal parentContext;\n\n\tconst ColorPalette({ \n\t\t@required this.parentContext,\n\t});\n\n\t@override\n\tWidget build(BuildContext context) {\n\t\treturn Dialog(\n\t\t\tbackgroundColor: Color(c1),\n\t\t\tclipBehavior: Clip.hardEdge,\n\t\t\tinsetPadding: EdgeInsets.all(MediaQuery.of(context).size.width * 0.03),\n\t\t\tshape: RoundedRectangleBorder(\n\t\t\t\tborderRadius: BorderRadius.circular(2),\n\t\t\t),\n\t\t\tchild: Container(\n\t\t\t\tpadding: EdgeInsets.all(8),\n\t\t\t\tchild: Wrap(\n\t\t\t\t\talignment: WrapAlignment.start,\n\t\t\t\t\tspacing: MediaQuery.of(context).size.width * 0.02,\n\t\t\t\t\trunSpacing: MediaQuery.of(context).size.width * 0.02,\n\t\t\t\t\tchildren: NoteColors.entries.map((entry) {\n\t\t\t\t\t\treturn GestureDetector(\n\t\t\t\t\t\t\tonTap: () => Navigator.of(context).pop(entry.key),\n\t\t\t\t\t\t\tchild: Container(\n\t\t\t\t\t\t\t\twidth: MediaQuery.of(context).size.width * 0.12,\n\t\t\t\t\t\t\t\theight: MediaQuery.of(context).size.width * 0.12,\n\t\t\t\t\t\t\t\tdecoration: BoxDecoration(\n\t\t\t\t\t\t\t\t\tborderRadius: BorderRadius.circular(MediaQuery.of(context).size.width * 0.06),\n\t\t\t\t\t\t\t\t\tcolor: Color(entry.value['b']),\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t);\n\t\t\t\t\t}).toList(),\n\t\t\t\t),\n\t\t\t),\n\t\t);\n\t}\n}\n``` \n\nAs we already stored different colors in **NoteColors** Map object, we iterate this object and fill the color palette with bright colors.\n\n![Color Palette:=:60](note-app-flutter/notes-app-color-palette.jpg)\n\n### Save notes\n\nWe have everything to save notes in the database. We save a note in the database if **backButton** is pressed at the top. Now add a function to handle **backButton** **onPressed**.\n\n```dart\nvoid handleBackButton() async {\n\tif (noteTitle.length == 0) {\n\t\t// Go Back without saving\n\t\tif (noteContent.length == 0) {\n\t\t\tNavigator.pop(context);\n\t\t\treturn;\n\t\t}\n\t\telse {\n\t\t\tString title = noteContent.split('\\n')[0];\n\t\t\tif (title.length > 31) {\n\t\t\t\ttitle = title.substring(0, 31);\n\t\t\t}\n\t\t\tsetState(() {\n\t\t\t\tnoteTitle = title;\n\t\t\t});\n\t\t}\n\t}\n\n\t// Save New note\n\tNote noteObj = Note(\n\t\ttitle: noteTitle, \n\t\tcontent: noteContent, \n\t\tnoteColor: noteColor\n\t);\n\ttry {\n\t\tawait _insertNote(noteObj);\n\t} catch (e) {\n\t\tprint('Error inserting row');\n\t} finally {\n\t\tNavigator.pop(context);\n\t\treturn;\n\t}\n}\n```\n\nThis function calls **_insertNote()** which saves the note object in the database.\n\n```dart\nFuture<void> _insertNote(Note note) async {\n  NotesDatabase notesDb = NotesDatabase();\n  await notesDb.initDatabase();\n  int result = await notesDb.insertNote(note);\n  await notesDb.closeDatabase();\n}\n``` \n\nWe have saved notes in the database, now in the Home screen, display the saved notes in list view.\n\n---\n\n## Show saved notes on the Home screen\n\nWe can retrieve saved notes from the database and we use that retrieved data to show a note as a list on the Home screen. As retrieving data from the database is an async task and we need to have data before building the Home widget, we use [FutureBuilder](https://api.flutter.dev/flutter/widgets/FutureBuilder-class.html).\n\n```dart\nFuture<List<Map<String, dynamic>>> readDatabase() async {\n\ttry {\n\t  NotesDatabase notesDb = NotesDatabase();\n\t  await notesDb.initDatabase();\n\t  List<Map> notesList = await notesDb.getAllNotes();\n\t  await notesDb.closeDatabase();\n\t  List<Map<String, dynamic>> notesData = List<Map<String, dynamic>>.from(notesList);\n\t \tnotesData.sort((a, b) => (a['title']).compareTo(b['title']));\n\t  return notesData;\n\t} catch(e) {\n\t\tprint('Error retrieving notes');\n\t\treturn [{}];\n\t}\n}\n```\n\nThis function reads all saved notes in the database and returns them as **Future** objects. We call this function in FutureBuilder and it builds the note list which displays each notes as a list.\n\nBefore that add necessary imports in **home.dart** to handle the database, to store note object and colors.\n\n```dart\nimport '../models/note.dart';\nimport '../models/notes_database.dart';\nimport '../theme/note_colors.dart';\n```\nStore read notes from database in state and define other state variables\n\n```dart\nList<Map<String, dynamic>> notesData;\nList<int> selectedNoteIds = [];\n```\n\n**notesData** stores all notes data read from database and **selectedNoteIds** will have a list of selected notes when a note is selected in Home.\n\n```dart\nbody: FutureBuilder(\n\tfuture: readDatabase(),\n\tbuilder: (context, snapshot) {\n\t\tif (snapshot.hasData) {\n\t\t\tnotesData = snapshot.data;\n\t\t\treturn Stack(\n\t\t\t\tchildren: <Widget>[\n\t\t\t\t\t// Display Notes\n\t\t\t\t\tAllNoteLists(\n\t\t\t\t\t\tsnapshot.data,\n\t\t\t\t\t\tthis.selectedNoteIds,\n\t\t\t\t\t\tafterNavigatorPop,\n\t\t\t\t\t\thandleNoteListLongPress,\n\t\t\t\t\t\thandleNoteListTapAfterSelect,\n\t\t\t\t\t),\n\t\t\t\t],\n\t\t\t);\n\t\t} else if (snapshot.hasError) {\n\t\t\tprint('Error reading database');\n\t\t} else {\n\t\t\treturn Center(\n\t\t\t\tchild: CircularProgressIndicator(\n\t\t\t\t\tbackgroundColor: Color(c3),\n\t\t\t\t),\n\t\t\t);\n\t\t}\n\t}\n),\n```\n\nHere before building the widget we read the data from the database and builds a list of note widgets to display on the Home screen by calling **AllNoteLists** widget. We also pass different callback functions to **AllNoteLists** to handles cases like the long selection of note, deselect a note, etc.\n\nDefine all these functions inside **_Home**\n\n```dart\n// Render the screen and update changes\nvoid afterNavigatorPop() {\n\tsetState(() {});\n}\n\n// Long Press handler to display bottom bar\nvoid handleNoteListLongPress(int id) {\n\tsetState(() {\n\t\tif (selectedNoteIds.contains(id) == false) {\n\t\t\tselectedNoteIds.add(id);\n\t\t}\n\t});\n}\n\n// Remove selection after long press\nvoid handleNoteListTapAfterSelect(int id) {\n\tsetState(() {\n\t\tif (selectedNoteIds.contains(id) == true) {\n\t\t\tselectedNoteIds.remove(id);\n\t\t}\n\t});\n}\n\n// Delete Note/Notes\nvoid handleDelete() async {\n\ttry {\n\t\tNotesDatabase notesDb = NotesDatabase();\n\t\tawait notesDb.initDatabase();\n\t\tfor (int id in selectedNoteIds) {\n\t\t\tint result = await notesDb.deleteNote(id);\n\t\t}\n\t\tawait notesDb.closeDatabase();\n\t} catch (e) {\n\n\t} finally {\n\t\tsetState(() {\n\t\t\tselectedNoteIds = [];\n\t\t});\n\t}\n}\n```\n\nDefine **AllNoteLists** widget which gets arguments from parent widget including note data and callback functions to handle\n\n```dart\n// Display all notes\nclass AllNoteLists extends StatelessWidget {\n\tfinal data;\n\tfinal selectedNoteIds;\n\tfinal afterNavigatorPop;\n\tfinal handleNoteListLongPress;\n\tfinal handleNoteListTapAfterSelect;\n\n\tAllNoteLists(\n\t\tthis.data, \n\t\tthis.selectedNoteIds,\n\t\tthis.afterNavigatorPop,\n\t\tthis.handleNoteListLongPress,\n\t\tthis.handleNoteListTapAfterSelect,\n\t);\n\n\t@override\n\tWidget build(BuildContext context) {\n\t\treturn ListView.builder(\n\t\t\titemCount: data.length,\n\t\t\titemBuilder: (context, index) {\n\t\t\t\tdynamic item = data[index];\n\t\t\t\treturn DisplayNotes(\n\t\t\t\t\titem,\n\t\t\t\t\tselectedNoteIds,\n\t\t\t\t\t(selectedNoteIds.contains(item['id']) == false? false: true),\n\t\t\t\t\tafterNavigatorPop, \n\t\t\t\t\thandleNoteListLongPress,\n\t\t\t\t\thandleNoteListTapAfterSelect,\n\t\t\t\t);\n\t\t\t}\n\t\t);\n\t}\n}\n\n\n// A Note view showing title, first line of note and color\nclass DisplayNotes extends StatelessWidget {\n\tfinal notesData;\n\tfinal selectedNoteIds;\n\tfinal selectedNote;\n\tfinal callAfterNavigatorPop;\n\tfinal handleNoteListLongPress;\n\tfinal handleNoteListTapAfterSelect;\n\n\tDisplayNotes(\n\t\tthis.notesData,\n\t\tthis.selectedNoteIds,\n\t\tthis.selectedNote,\n\t\tthis.callAfterNavigatorPop,\n\t\tthis.handleNoteListLongPress,\n\t\tthis.handleNoteListTapAfterSelect,\n\t);\n\n\t@override\n\tWidget build(BuildContext context) {\n\t\treturn Padding(\n\t\t\tpadding: const EdgeInsets.symmetric(horizontal: 8.0, vertical: 2.0),\n\t\t\tchild: Material(\n\t\t\t\televation: 1,\n\t\t\t\tcolor: (selectedNote == false? Color(c1): Color(c8)),\n\t\t\t\tclipBehavior: Clip.hardEdge,\n\t\t\t\tborderRadius: BorderRadius.circular(5.0),\n\t\t\t\tchild: InkWell(\n\t\t\t\t\tonTap: () {\n\t\t\t\t\t\tif (selectedNote == false) {\n\t\t\t\t\t\t\tif (selectedNoteIds.length == 0) {\n\t\t\t\t\t\t\t\t// Go to edit screen to update notes\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\thandleNoteListLongPress(notesData['id']);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} \n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\thandleNoteListTapAfterSelect(notesData['id']);\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\n\t\t\t\t\tonLongPress: () {\n\t\t\t\t\t\thandleNoteListLongPress(notesData['id']);\n\t\t\t\t\t},\n\t\t\t\t\tchild: Container(\n\t\t\t\t\t\twidth: MediaQuery.of(context).size.width,\n\t\t\t\t\t\tpadding: const EdgeInsets.symmetric(horizontal: 8.0, vertical: 8.0),\n\t\t\t\t\t\tchild: Row(\n\t\t\t\t\t\t\tchildren: <Widget>[\n\t\t\t\t\t\t\t\tExpanded(\n\t\t\t\t\t\t\t\t\tflex: 1,\n\t\t\t\t\t\t\t\t\tchild: Column(\n\t\t\t\t\t\t\t\t\t\tmainAxisAlignment: MainAxisAlignment.center,\n\t\t\t\t\t\t\t\t\t\tcrossAxisAlignment: CrossAxisAlignment.center,\n\t\t\t\t\t\t\t\t\t\tmainAxisSize: MainAxisSize.min,\n\t\t\t\t\t\t\t\t\t\tchildren: <Widget>[\n\t\t\t\t\t\t\t\t\t\t\tContainer(\n\t\t\t\t\t\t\t\t\t\t\t\talignment: Alignment.center,\n\t\t\t\t\t\t\t\t\t\t\t\tdecoration: BoxDecoration(\n\t\t\t\t\t\t\t\t\t\t\t\t\tcolor: (selectedNote == false? \n\t\t\t\t\t\t\t\t\t\t\t\t\t\tColor(NoteColors[notesData['noteColor']]['b']):\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tColor(c9)\n\t\t\t\t\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t\t\t\t\t\tshape: BoxShape.circle,\n\t\t\t\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t\t\t\t\tchild: Padding(\n\t\t\t\t\t\t\t\t\t\t\t\t\tpadding: EdgeInsets.all(10),\n\t\t\t\t\t\t\t\t\t\t\t\t\tchild: (\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tselectedNote == false?\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tText(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tnotesData['title'][0],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tstyle: TextStyle(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcolor: Color(c1),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfontSize: 21,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t):\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tIcon(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tIcons.check,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcolor: Color(c1),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsize: 21,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t),\n\n\t\t\t\t\t\t\t\tExpanded(\n\t\t\t\t\t\t\t\t\tflex: 5,\n\t\t\t\t\t\t\t\t\tchild: Column(\n\t\t\t\t\t\t\t\t\t\tmainAxisAlignment: MainAxisAlignment.spaceAround,\n\t\t\t\t\t\t\t\t\t\tcrossAxisAlignment: CrossAxisAlignment.start,\n\t\t\t\t\t\t\t\t\t\tmainAxisSize: MainAxisSize.min,\n\t\t\t\t\t\t\t\t\t\tchildren:<Widget>[\n\t\t\t\t\t\t\t\t\t\t\tText(\n\t\t\t\t\t\t\t\t\t\t\t\tnotesData['title'] != null? notesData['title']: \"\",\n\t\t\t\t\t\t\t\t\t\t\t\tstyle: TextStyle(\n\t\t\t\t\t\t\t\t\t\t\t\t\tcolor: Color(c3),\n\t\t\t\t\t\t\t\t\t\t\t\t\tfontSize: 18,\n\t\t\t\t\t\t\t\t\t\t\t\t\tfontWeight: FontWeight.bold,\n\t\t\t\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t\t\t\t),\n\n\t\t\t\t\t\t\t\t\t\t\tContainer(\n\t\t\t\t\t\t\t\t\t\t\t\theight: 3,\n\t\t\t\t\t\t\t\t\t\t\t),\n\n\t\t\t\t\t\t\t\t\t\t\tText(\n\t\t\t\t\t\t\t\t\t\t\t\tnotesData['content'] != null? notesData['content'].split('\\n')[0]: \"\",\n\t\t\t\t\t\t\t\t\t\t\t\tstyle: TextStyle(\n\t\t\t\t\t\t\t\t\t\t\t\t\tcolor: Color(c7),\n\t\t\t\t\t\t\t\t\t\t\t\t\tfontSize: 16,\n\t\t\t\t\t\t\t\t\t\t\t\t\tfontWeight: FontWeight.w300,\n\t\t\t\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t],\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t),\n\t\t);\n\t}\n}\n```\n\n**AllNoteLists** builds a list of notes from the Map of a list of notes. In **ListView** builder it passes each note extracted data to another widget **DisplayNotes** which represents each note. \n\nNow Home screen displays all notes stored as\n\n![Home screen:=:30](note-app-flutter/notes-app-home-notes-list.jpg)\n\nLong press on the note to select the note. And if a note is selected we can add a delete action to delete the selected notes. Add **Delete** button at **appBar** **actions** which shows delete icon only if any note is selected.\n\n```dart\nactions: [\n\t(selectedNoteIds.length > 0?\n\t\tIconButton(\n\t\t\ticon: const Icon(\n\t\t\t\tIcons.delete,\n\t\t\t\tcolor: const Color(c1),\n\t\t\t),\n\t\t\ttooltip: 'Delete',\n\t\t\tonPressed: () => handleDelete(),\n\t\t):\n\t\tContainer()\n\t),\n],\n```\n\nDefine **hanldeDelete()** which deletes all selected notes from database.\n\n```dart\n// Delete Notes\nvoid handleDelete() async {\n\ttry {\n\t\tNotesDatabase notesDb = NotesDatabase();\n\t\tawait notesDb.initDatabase();\n\t\tfor (int id in selectedNoteIds) {\n\t\t\tint result = await notesDb.deleteNote(id);\n\t\t}\n\t\tawait notesDb.closeDatabase();\n\t} catch (e) {\n\t\tprint('Cannot delete notes');\n\t} finally {\n\t\tsetState(() {\n\t\t\tselectedNoteIds = [];\n\t\t});\n\t}\n}\n```\n\nFor notes, we have added create, read and delete functions. Now we will add an update function to edit already stored notes.\n\n### Update notes\n\nFor this, we can use the Edit screen to update the notes as it has all features to create notes which are similar for update notes also. We have to tell the Edit screen which type of notes operations we doing either create or update notes. To inform the Edit screen we can pass arguments to **NotesEdit** widget while routing about the type of action and notes data if the action is to update. Change **NotesEdit** widget to accept arguments telling the type of action and necessary data.\n\n```dart\nclass NotesEdit extends StatefulWidget {\n\tfinal args;\n\n\tconst NotesEdit(this.args);\n\t_NotesEdit createState() => _NotesEdit();\n}\n```\n\n**args** stores parameters passed from parent widget.\n\nChange navigation arguments for **NotesEdit** in the floating-action-button in **_Home**.\n\n```dart\n//Floating Button\nfloatingActionButton: FloatingActionButton(\n\tchild: const Icon(\n\t\tIcons.add,\n\t\tcolor: const Color(c5),\n\t),\n\ttooltip: 'New Notes',\n\tbackgroundColor: const Color(c4),\n\tonPressed: () {\n\t  Navigator.push(\n\t  \tcontext,     \n\t    MaterialPageRoute(builder: (context) => NotesEdit(['new', {}])),\n\t  );\n\t}\n),\n```\n\nAs floating-button triggers the creation of a new note, we pass argument **new** to inform **NotesEdit** that operation in creation of note.\n\nWhen tapped on a note on the Home screen we navigate to the Edit screen to update the note. For this add navigation from Home to Edit when tapped on the note in **DisplayNotes**.\n\n```dart\nchild: InkWell(\nonTap: () {\n\tif (selectedNote == false) {\n\t\tif (selectedNoteIds.length == 0) {\n\t\t\tNavigator.push(\n\t\t\t\tcontext, \n        MaterialPageRoute(\n          builder: (context) => NotesEdit(['update', notesData]),\n        ),\n\t\t\t).then((dynamic value) {\n\t\t\t\t\tcallAfterNavigatorPop();\n\t\t\t\t}\n\t\t\t);\n\t\t\treturn;\t\t\n\t\t}\n\t\telse {\n\t\t\thandleNoteListLongPress(notesData['id']);\n\t\t}\n\t} \n\telse {\n\t\thandleNoteListTapAfterSelect(notesData['id']);\n\t}\n},\n```\n\nWe pass **update** and **notesData** to the Edit screen stating the operation is updating notes and note data to fill in the Edit screen.\n\nChange **NotesEdit** widget in **notes_edit.dart** for handling update note operation.\n\n```dart\n@override\nvoid initState() {\n\tsuper.initState();\n\tnoteTitle = (widget.args[0] == 'new'? '': widget.args[1]['title']);\n\tnoteContent = (widget.args[0] == 'new'? '': widget.args[1]['content']);\n\tnoteColor = (widget.args[0] == 'new'? 'red': widget.args[1]['noteColor']);\n\n\t_titleTextController.text = (widget.args[0] == 'new'? '': widget.args[1]['title']);\n\t_contentTextController.text = (widget.args[0] == 'new'? '': widget.args[1]['content']);\n\t_titleTextController.addListener(handleTitleTextChange);\n\t_contentTextController.addListener(handleNoteTextChange);\n}\n\nvoid handleBackButton() async {\n\tif (noteTitle.length == 0) {\n\t\t// Go Back without saving\n\t\tif (noteContent.length == 0) {\n\t\t\tNavigator.pop(context);\n\t\t\treturn;\n\t\t}\n\t\telse {\n\t\t\tString title = noteContent.split('\\n')[0];\n\t\t\tif (title.length > 31) {\n\t\t\t\ttitle = title.substring(0, 31);\n\t\t\t}\n\t\t\tsetState(() {\n\t\t\t\tnoteTitle = title;\n\t\t\t});\n\t\t}\n\t}\n\n\t// Save New note\n\tif (widget.args[0] == 'new') {\n\t\tNote noteObj = Note(\n\t\t\ttitle: noteTitle, \n\t\t\tcontent: noteContent, \n\t\t\tnoteColor: noteColor\n\t\t);\n\t\ttry {\n\t\t\tawait _insertNote(noteObj);\n\t\t} catch (e) {\n\n\t\t} finally {\n\t\t\tNavigator.pop(context);\n\t\t\treturn;\n\t\t}\n\t}\n\t\n\t// Update Note\n\telse if (widget.args[0] == 'update') {\n\t\tNote noteObj = Note(\n\t\t\tid: widget.args[1]['id'],\n\t\t\ttitle: noteTitle, \n\t\t\tcontent: noteContent, \n\t\t\tnoteColor: noteColor\n\t\t);\n\t\ttry {\n\t\t\tawait _updateNote(noteObj);\n\t\t} catch (e) {\n\n\t\t} finally {\n\t\t\tNavigator.pop(context);\n\t\t\treturn;\n\t\t}\n\t}\n}\n```\n\nTapping on the note in the Home screen will take us to the Edit screen to update notes.\n\n---\n\nThis tutorial addressed how to create a simple note-taking app in Flutter with common operations like create, read, update and delete. We can extend the app to have multiple day-to-day useful features. I hope you will do that to create your own notes app according to your interests and needs.\n\nI have created a full Android working application with additional features like Notes sharing, multi-select notes, deleting notes in the edit screen, sort text in notes, etc. Check out the full code at [github.com/santhalakshminarayana/zehero-note](https://github.com/santhalakshminarayana/zehero-note)."},{"metadata":{"title":"Build Blog with Next.js and MDX & Deploy to Github Pages","description":"Create a blog with Next.js as Static Site Generator, MDX for writing content, Github Pages for deploying the static website. Also add SEO and Image optimization.","imgName":"blog-nextjs-mdx/nextjs.jpeg","date":"Dec 31, 2020","tags":["react","next-js"],"keywords":["react'","next.js","blog","mdx","markdown","gh-pages","github-pages"],"id":"build-blog-with-nextjs-mdx-and-deploy-to-github-pages"},"content":"\n![Build Blog with Next.js & MDX and Deploy to Github Pages](blog-nextjs-mdx/nextjs.jpeg)\n\n# Build Blog with Next.js & MDX and Deploy to Github Pages\n\nIn this post, we will discuss how to create and publish a blog with [Next.js](https://nextjs.org/), write content with [MDX](https://mdxjs.com/), deploy static site to Github Pages, Image optimization to reduce the page load time and SEO for better page ranking.\n\n> Pre-requisites: Basic understanding of React and Markdown. \n\nBuilding a blog with Next.js is very easy and it is simple to understand, develop, and maintain the dynamic websites and credit goes to Next.js dynamic paging which lets the creation of dynamic URLs and routing. When I decided to start my blog then I searched and read about many frameworks like Vanilla React, Gatsby, Hugo, etc., After reading many blogs, comments, and reviews I felt Next.js would be the option I was looking for. \n\nNext.js offers everything need to create a blog:\n- Static site export support\n- Dynamic routing\n- MDX (markdown with JSX) support\n- Image optimization\n- SEO\n\nNow dive in to create a simple blog\n\n## Setup Next.js and MDX\nNext.js is a React framework to create SPA (single page applications) and enables both static websites and server-side rendering. Here we'll focus only on static website generation.\n\n### Install Next.js\n\n[Install Next.js](https://nextjs.org/docs/getting-started#setup) by typing any of the following commands\n\n```bash\nnpx create-next-app\n# or\nyarn create next-app\n```\n\n_create-next-app_ installs everything needed to start with. \n\nThe most important thing in Next.js is the **pages** directory. Every component exported from **.js**, **.jsx**, **.ts**, or **.tsx** in the pages folder is treated as a page and each page associates with a route based on its file name. In the pages folder, the **App** component from **\\_app.js** serves as the initialization of pages that can be edited for custom use like global style declaration, CDN's, etc., **index.js** is the starting point for adding content.\n\nTo write content in articles we use MDX, which lets us write JSX in Markdown (**.mdx** file). Writing in markdown is as beautiful as it is like writing in a text file and can render as HTML tags. Besides easy export and maintenance of articles, we can also reuse these files in another framework/platform which supports MDX without rewriting.\n\n### Install MDX\n\nInstall necessary plugins for MDX\n\n```bash\nyarn add @next/mdx gray-matter next-mdx-remote\n```\n\nWe installed _@next/mdx_ to handle **.mdx** files in pages directory, _gray-matter_ is to parse content from markdown and _next-mdx-remote_ for rendering markdown as HTML.\n\nNow create / open **next.config.js** (configuration file for Next.js) at the project root level and add the following to configure MDX and handle **.mdx** page extensions in the pages folder.\n\n```js\nconst withMDX = require('@next/mdx')({\n  extension: /\\.mdx?$/,\n})\nmodule.exports = withMDX({\n  pageExtensions: ['js', 'jsx', 'mdx'],\n  target: 'serverless',\n})\n``` \nAs Next.js only looks for **.js** or **.jsx** files and gives routing to these pages, the above configuration tells Next.js to treat **.md** or **.mdx** files as pages and provide routing.\n\nAs we are creating a static site, **target: 'serverless'** notifies Next.js to generate static files for us.\n\nOpen **package.json** file in the root directory and add **deploy** command to export all static files as a folder as **out** (can have a different name) at the root level. After installing plugins and adding values **package.json** might look like this\n\n```json\n{\n  \"name\": \"blog\",\n  \"version\": \"0.1.0\",\n  \"private\": true,\n  \"scripts\": {\n    \"dev\": \"next dev\",\n    \"build\": \"next build\",\n    \"start\": \"next start\",\n    \"export\": \"next export\",\n    \"deploy\": \"npm run build && npm run export\"\n  },\n  \"dependencies\": {\n    \"@next/mdx\": \"^10.0.4\",\n    \"gray-matter\": \"^4.0.2\",\n    \"imagemin-mozjpeg\": \"^9.0.0\",\n    \"imagemin-optipng\": \"^8.0.0\",\n    \"next\": \"10.0.4\",\n    \"next-mdx-remote\": \"^2.0.1\",\n    \"next-optimized-images\": \"^2.6.2\",\n    \"react\": \"17.0.1\",\n    \"react-dom\": \"17.0.1\",\n    \"webp-loader\": \"^0.6.0\"\n  }\n}\n\n```\n\nLet's give some break to configuration and take a turn to add some content.\n\n## Home Page\n\nAs said earlier **index.js** is the pivot file and also the Home page for our website. So let's edit our Home page and customize it like below.\n\n```js:pages/index.js\nexport default function Home() {\n  return (\n    <div className = 'info-container'>\n      <img src = 'batman.png' alt = 'Batman Logo'/>\n      <p className = 'info-description'>Hi I'm Batman, the saviour of Gotham City and I like to roam in nights to bash the bad guys.</p>\n      <p className = 'info-description'>But please don't call me as a source for <b>Corona Virus</b> and it could be the <b>Joker</b> who \n      might have started this mess.</p>\n\n      <style jsx>{`\n        .info-container {\n          margin: 0 5% 0 5%;\n        }\n\n        img {\n          width: 20%;\n          max-width: 20%;\n          height: auto;\n          margin-left: 40%;\n        }\n\n        .info-description {\n          font-size: 20px;\n        }\n      `}</style>\n    </div>\n  )\n}\n```\n\nIn the above snippet, **CSS** styles are provided inside the component. This is called **CSS-In-JS**, which is possible as Next.js bundles **styled-jsx**. There are many ways to add [CSS in Next.js](https://nextjs.org/docs/basic-features/built-in-css-support).\n\nIn the **img** tag above, **src** is provided with the name of the image only but not relative/absolute path. In Next.js we don't need to provide complete paths if we place any assets (like images, videos) in the **public** folder. Next.js automatically prepends the path at build time for assets in the public folder.\n\nNow to see changes, start localhost (default port is 3000) as a dev server\n```bash\n# starts localhost at port 8000\nyarn dev -p 8000\n```\n\nOpen any desktop browser and type URL http://localhost:port/ to see changes.\nFor the above code, the display is like below\n\n![First preview](blog-nextjs-mdx/nextjs-blog-display.jpg)\n\nWe have a home page with a welcome message. Now some create blog posts with MDX.\n\n## Write Blog Content with MDX\n\nCreate a directory to store our markdown posts at the root level or any accessible place. \n\n```shell\nmkdir posts\n```\n\nWrite some content in a markdown file and save it as '.mdx' inside the **posts** directory. I have created two posts and saved them as **batman-vs-superman.mdx** and **justice-league.mdx**.\n\n```markdown:posts/batman-vs-superman.mdx\n---\ntitle: \"Batman VS Superman\"\ndescription: \"An intense fight between two superheroes, me and Superman.\"\ndate: \"Mar 25, 2016\"\n---\n\n# Batman VS Superman\n\nI and Superman accidentally met (fight) and later realized there was a culprit (Lex Luthor) who we should fight.\n\nAs usual, it cost a whopping $250 million for this high-action story.\n```\n\n```markdown:posts/justice-league.mdx\n---\ntitle: \"Justice League\"\ndescription: \"Grand union with fellow superheroes which costs $300 million but received face slap from the audience.\"\ndate: \"Nov 17, 2017\"\n---\n\n# Justice League\n\nSuperheroes from the DC universe consisting of Superman, Wonder Woman, The Flash, Aquaman, and Cyborg and I met in 2017 to spoil the party plans of Steppenwolf who tried to steal Mother Boxes on Earth.\n\nIt's a very long story of how we met each other and all thanks to Avengers who had inspired me to search for other superheroes.\n```\n\nIn the above snippet content inside **---** is used as metadata to make routing for this **.mdx** file. We'll discuss this later.\n\n## Show blog posts on the Home page\n\n### Fetch posts data\n\nTo show our blog posts on the Home page, we have to fetch the **.mdx** files and parse content. We can also provide routing from the home page to any blog post. We write the logic to fetch the **.mdx** files to read the content inside and extract metadata useful to display posts on the Home page. These files should be separated from routing, so at the root level create a folder called **lib** where we store all program files to extract **.mdx** content. Inside **lib** create a file with name **getPostsData.js** which returns posts data like markdown content, title, path, etc.,\n\n```js:lib/getPostsData.js\nconst fs = require('fs');\nconst path = require('path');\nconst matter = require(\"gray-matter\");\n\n// current 'posts' directory\nconst postsDirectory = path.join(process.cwd(), 'posts');\nconst mdx_file_extention = '.mdx';\n\nfunction getAllFilesInDirectory() {\n  const fileNames = fs.readdirSync(postsDirectory);\n  return fileNames.map((fileName) => {\n    return path.parse(fileName)\n  })\n}\n\nfunction getMdxFiles() {\n  const allFiles = getAllFilesInDirectory();\n  return allFiles.filter(parsedFile => parsedFile.ext == mdx_file_extention);\n}\n\nexport function getAllPostsPath() {\n  const allMdxFiles = getMdxFiles();\n  return allMdxFiles.map((parsedFile) => {\n    return {\n      params: {\n        id: parsedFile.name\n      }\n    }\n  })\n}\n\nexport function getPostsMetaData() {\n  const allMdxFiles = getMdxFiles();\n\n  const postsMetaData = allMdxFiles.map((parsedFile) => {\n    const fullPath = path.join(postsDirectory, parsedFile.base);\n\n    // get MDX metadata and content\n    const fileContents = fs.readFileSync(fullPath, 'utf8');\n    // get metadata, content\n    const { data, content } = matter(fileContents);\n    let metadata = data;\n    metadata['id'] = parsedFile.name;\n    return metadata;\n  });\n  return postsMetaData;\n}\n\nexport function getPostData(id) {\n  const fullPath = path.join(postsDirectory, id + mdx_file_extention);\n\n  // get MDX metadata and content\n  const fileContents = fs.readFileSync(fullPath, 'utf8');\n  // get metadata, content\n  const { data, content } = matter(fileContents);\n\n  let metadata = data;\n  metadata['id'] = id;\n\n  return {'metadata': metadata, 'content': content};\n}\n```\n\n**getAllPostsPath** function returns all **.mdx** files path names to serve as URLs for dynamic routing of a page.\n\n**getPostsMetaData** function returns all **.mdx** files metadata (data inside **---**) which we use to gather information like title, description, etc., and function **getPostsData** returns both metadata and markdown content to render for a particular file we request through argument **id**. **gray-matter** parses the markdown file into metadata (data inside **---**) and markdown content to render.\n\nIf encountered error while accessing **fs** add the following to _next.config.js_\n\n```js:next.config.js\nconst withMDX = require('@next/mdx')({\n  extension: /\\.mdx?$/,\n})\n\nmodule.exports = withMDX({\n\twebpack: (config, { isServer }) => {\n\t\tif (!isServer) {\n\t  \tconfig.node = {\n\t    fs: 'empty'\n\t \t\t}\n\t\t}\n\treturn config\n\t},\n  pageExtensions: ['js', 'jsx', 'mdx'],\n  target: 'serverless',\n})\n```\n### Provide posts data to Home page\n\nWe have to call the **getallPostsData** function to get data. But how can we pass this data to the component in **pages/index.js**? Don't worry we can pass data as **props** to the component before rendering using the [getStaticProps](https://nextjs.org/docs/basic-features/data-fetching#getstaticprops-static-generation) function. **getStaticProps** allows us to fetch any dynamic data to provide before rendering the component. Change **pages/index.js** as \n\n```js:pages/index.js\nimport { getPostsMetaData } from '../lib/getPostsData.js';\n\nexport default function Home({ postsData }) {\n  return (\n    <div className = 'info-container'>\n      <img src = 'batman.png' alt = 'Batman Logo'/>\n      <p className = 'info-description'>Hi I'm Batman, the saviour of Gotham City and I like to roam in nights to bash the bad guys.</p>\n      <p className = 'info-description'>But please don't call me as a source for <b>Corona Virus</b> and it could be the <b>Joker</b> who \n      might have started this mess.</p>\n      <hr/>\n      {postsData.map((metadata) => {\n        return (\n          <div key = {metadata.id}>\n            <h2 className = 'post-title'>{metadata.title}</h2>\n            <p className = 'post-description'>{metadata.description}</p>\n          </div>\n          )\n        })}\n\n      <style jsx>{`\n        .info-container {\n          margin: 0 5% 0 5%;\n        }\n\n        img {\n          width: 20%;\n          max-width: 20%;\n          height: auto;\n          margin-left: 40%;\n        }\n\n        .info-description {\n          font-size: 20px;\n        }\n\n        .post-title {\n          font-size: 24px;\n          color: black;\n        }\n\n        .post-description {\n          font-size: 16px;\n          color: #000000e6;\n        }\n      `}</style>\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  const postsData = getPostsMetaData();\n  return {\n    props: {\n      postsData: postsData,\n    }\n  }\n}\n```\n\nWhich displays as \n\n![MDX blog posts display on Home page](blog-nextjs-mdx/blog-posts-display-on-home-page.jpg)\n\n## Rendering MDX and providing dynamic routing\n\nSo far so good until we want to display **.mdx** files as individual webpages. Right now it is not possible because Next.js only treats components exported inside the **pages** folder as webpages and provides routing, to provide routing for our posts we must export content from the **posts** directory to the **pages** folder. This is where we should spend some time to serve markdown files as webpages. \n\nThe beauty of Next.js is that we can dynamically serve pages by fetching these **.mdx** files and provide routing inside the **pages** directory with having dynamic pages.\n\nCreate **blog** folder inside the **pages** folder and inside this **blog** folder create a file with name **[id].js**. Dynamic routes in Next.js are identified by **[]** (square brackets) in the filename. We can provide any query parameter to this **[]** page component which will end up as *http://localhost:8000/blog/post-name* for **post-name.js**. Now add following code to *pages/blog/**[id]**.js*\n\n```js:pages/blog/[id].js\nimport renderToString from 'next-mdx-remote/render-to-string';\nimport hydrate from 'next-mdx-remote/hydrate';\nimport { getAllPostsPath, getPostData } from '../../lib/getPostsData.js';\n\nconst components = {\n\th1: props => <h1 style = {{ \n\t\tfontSize: 'calc(1rem + 1.5vw)', \n\t\tcolor: 'black',\n\t\tmargin: '1vh 0 1vh 0', }} \n\t\t{...props} />,\n\n\tp: props => <p style = {{ \n\t\tfontSize: 'calc(1rem + 0.1vw)', \n\t\tcolor: '#000000e6',\n\t\tmargin: '0vh 0 1vh 0' }} \n\t\t{...props} />,\n}\n\nexport default function Blog({ postMetadata, postContent }) {\n\tconst content = hydrate(postContent, { components });\n\n\treturn (\n\t\t<div>\n\t\t\t<div className = 'blog-content'>\n\t\t\t\t{content}\n\t\t\t</div>\n\n\t\t\t<style jsx>{`\n\t\t\t\t.blog-content {\n\t\t\t\t\tdisplay: flex;\n\t\t\t\t\tflex: 100%;\n\t\t\t\t\tflex-direction: column;\n\t\t\t\t\tmargin: 1vw 25vw 1vw 25vw;\n\t\t\t\t\twidth: 50vw;\n\t\t\t\t\tmax-width: 50vw;\n\t\t\t\t}\n\t\t  `}</style>\n\t\t\t\n\t\t</div>\n\t)\n}\n\nexport async function getStaticPaths() {\n\tconst paths = getAllPostsPath();\n\treturn {\n\t\tpaths,\n\t\tfallback: false,\n\t}\n}\n\nexport async function getStaticProps({ params }) {\n\tconst postData = await getPostData(params.id);\n\tconst mdxSource = await renderToString(postData.content, { components });\n\treturn {\n\t\tprops: {\n\t\t\tpostMetadata: postData.metadata,\n\t\t\tpostContent: mdxSource,\n\t\t\tid: params.id,\n\t\t}\n\t}\n}\n```\n\nIf any page provides dynamic routing we must provide all dynamic paths we want to serve to this page through the [getStaticPaths](https://nextjs.org/docs/basic-features/data-fetching#getstaticpaths-static-generation) function.\n\nWith **renderToString** and **hydrate** we parse markdown content to HTML string and render as plain HTML. To style the HTML tags in markdown, we pass custom tags as components to the MDX loader which maps tags automatically. In the above file two tags, **h1** and **p** are customized and combined as components.\n\nNow in the browser hit URL *http://localhost:3000/blog/batman-vs-superman* or *http://localhost:3000/blog/justice-league* to see the post. You might see output similar to below\n\n![MDX Post Display](blog-nextjs-mdx/mdx-post-display.jpg)\n\n## Navigation from the Home page\n\nWhat if we want to navigate from the Home page to blog posts by clicking on the title of the post? For this Next.js provides a [next/link](https://nextjs.org/docs/api-reference/next/link) component that takes care of dynamic routing from any page to another by pre-pending the necessary path before the page to navigate like navigation to **batman-vs-superman** results as *http://localhost:3000/blog/batman-vs-superman*. We must navigate like this only if we are not pre-pending the base URL manually inside the website. Now change **pages/index.js** to get dynamic navigation\n\n```js\nimport Link from 'next/link';\n{ ... }\n\n{postsData.map((metadata) => {\n  return (\n    <div key = {metadata.id}>\n      <Link href={`/blog/${metadata.id}`} key = {metadata.title} >\n        <a className = 'post-title'>{metadata.title}</a>\n      </Link>\n      <p className = 'post-description'>{metadata.description}</p>\n    </div>\n    )\n  })}\n\n { ... }\n```\n\n## Image Optimization\n\nImages take a lot of space in a webpage which reduces page loading time results in poor performance if the user has a poor internet connection. Images can be optimized many ways like converting all PNG/JPEG files to Webp/JPEG2000 format, [responsive images](https://developer.mozilla.org/en-US/docs/Learn/HTML/Multimedia_and_embedding/Responsive_images) for different screen dimensions by rescaling images, lazy loading, etc.,\n\nNext.js provides [next/image](https://nextjs.org/docs/api-reference/next/image) API for image optimization. But it needs the **next start** that runs on the node server which is not possible for static site generation. So we will use another plugin [next-optimized-images](https://github.com/cyrilwanner/next-optimized-images) which provides many options to optimize images.\n\nHere we will optimize images to serve in Webp format, to do so install **next-optimized-images**\n\n```shell\nnpm install next-optimized-images\n```\n\nBesides this install some additional plugins to convert PNG/JPEG to Webp format and loading Webp images.\n\n```shell\nnpm install imagemin-mozjpeg imagemin-optipng webp-loader\n```\n\nand change _next.config.js_ as\n\n```js:next.config.js\nconst withNextOptimizedImages = require('next-optimized-images');\n\nconst withMDX = require('@next/mdx')({\n  extension: /\\.mdx?$/,\n})\n\nmodule.exports = withNextOptimizedImages(\n\twithMDX({\n\t\twebpack: (config, { isServer }) => {\n\t\t\t\tif (!isServer) {\n\t\t  \t\tconfig.node = {\n\t\t    \tfs: 'empty'\n\t\t \t\t}\n\t\t\t}\n\t\t\treturn config\n\t\t},\n\t  pageExtensions: ['js', 'jsx', 'mdx'],\n\t  target: 'serverless',\n\t})\n)\n```\n\nIn build time **next-optimized-images** exports optimized images to **images** (custom name) folder inside _out/_next/static_. So create **images** directory at the root level and move images to this folder which needs optimization and provide relative paths now which were previously not required because of the **public** folder.\n\nChange the **img** tag in **pages/index.js** to\n\n```jsx\n<picture>\n  <source srcSet={require('../images/batman.png?webp')} type=\"image/webp\" />\n  <source srcSet={require('../images/batman.png')} type=\"image/png\" />\n  <img src={require('../images/batman.png')} alt = 'Batman Logo' />\n</picture>\n```\n\nThis will convert a PNG image to Webp format and loads Webp images. If the browser doesn't support Webp images **<picture\\>** will automatically load the normal PNG image.\n\nYou can more than this by exploring more about this plugin.\n\n## SEO in Next.js\n\nFor Single Application Websites (SPA) SEO is a major problem which Next.js takes care of this by providing API [next/head](https://nextjs.org/docs/api-reference/next/head) which behaves exactly like **<head\\>** in HTML. We can wrap meta properties, title, description, Open Graph (OG) properties, Twitter cards, etc., inside the **Head** component. For our Home page we can set title and description as \n\n![Seo in Next.js:=:80](blog-nextjs-mdx/seo-in-nextjs.jpg)\n\nIf you don't want to set meta properties, title, description, and others there are so many plugins like [next-seo](https://www.npmjs.com/package/next-seo) available which handle all of these manual adding for you.\n\n---\n\n## Deploy to Github pages\n\n### Export static files to deploy\n\nNow our website is ready to move from development to production. To host our site we can use the static-site-generator of Next.js to generate all pre-render pages bundled inside the **out** directory. Build and generate **out** directory by typing the below command in the terminal\n\n```shell\nyarn deploy\n```\n\nYou can find a new directory **out** at the root level which contains all dynamic pages pre-rendered and ready to serve as HTML pages on the client-side. We will use this folder to host our website on Github pages.\n\n### Set up Github Pages\n\nGithub Pages is a very great place to host static sites. But we need to push and configure deployment changes every time we add content to the website. This is where we utilize Github Actions which automates deployment actions according to the configuration file we provide. But first, create a repository in Github to store our code files and push source code to this repository on the **main** branch. We use the **gh-pages** branch to which Github Actions deploy static files for hosting. \n\nTo do this we must provide access for Github Actions to this repository to access source files. To provide access, go to [Github Settings -> tokens](https://github.com/settings/tokens) and create a new **personal access token** by checking **repo** scopes and others if you need and save as **GITHUB_TOKEN** (or any other name). Copy this **access code** and in the repository, move to the **secretes** tab in the **Settings** section and create a new secrete and copy this code. Remember the name of the secrete token you created in this repo for future purposes. \n\n![Github Repository Secretes Token:=:80](blog-nextjs-mdx/github-repo-secretes-token.jpg)\n\nIt's time to configure GitHub Actions. Create a directory called _.github/workflows_ at the root level locally. Create a file **integrate.yml** inside _.github/workflows_ and add the following configuration\n\n```yaml:.github/workflows/integrate.yml\nname: Build and Deploy\non: \n  push:\n    branches:\n      - master\njobs:\n  build-and-deploy:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v2.3.1\n        with:\n          persist-credentials: false\n\n      - name: Cache\n        uses: actions/cache@v2\n        with:\n          path: ${{ github.workspace }}/.next/cache\n          key: ${{ runner.os }}-nextjs-${{ hashFiles('**/package-lock.json') }}\n\n      - name: Install and Build\n        uses: actions/setup-node@v1\n      - run: npm install\n      - run: npm run build\n      - run: npm run export\n        env:\n            CI: true\n      - run: touch out/.nojekyll\n\n      - name: Deploy\n        uses: JamesIves/github-pages-deploy-action@3.7.1\n        with:\n          ACCESS_TOKEN: ${{ secrets.ACCESS_TOKEN }}\n          BRANCH: gh-pages \n          FOLDER: out\n          CLEAN: true\n```\nYou may have to replace **ACCESS_TOKEN** with your custom name. This is what we configured\n\n1. Execute workflow action on every push to the **master** branch.\n2. Run commands *npm install && npm run build && npm run export* to build and export static version of our website.\n3. Deploy contents inside **out** folder to the **gh-pages** branch.\n4. Added *touch out/.nojekyll* to **gh-pages** because Github pages **Jekyll** to render static sites. **Jekyll** ignores files in the directory starting with **_** and it is an issue for us because all our static assets are created in **\\_next** folder. **.nojekyll** tells Github Pages not to run published files through **Jekyll**.\n\nPush all changes to Github repo\n\n```shell\ngit add .\ngit commit -m \"initial deployment of the blog\"\ngit push -u origin master\n```\n\nThis will push all your working source files to the Github repo and Github Actions starts a workflow to deploy static files in the **out** folder to **gh-pages**.\n\nYou can monitor the status of the Github Actions workflow after every push to the **master** branch in the **Actions** tab.\n\nEnable Github Pages in the **Settings** section of the repo and for source select the **gh-pages** branch.\n\nIf everything worked properly you can have your website hosted at *https://<username\\>.github.io/<repo\\>*. Here **<repo\\>** name is **blog**. \n\n---\n\n## Manage CSS, assets, and page links to work properly\n\nIf you host the website at *https://<username\\>.github.io/<repo\\>* you can observe CSS or other static assets and routing not working properly. This is because Next.js assumes **out** directory hosted at root level as *https://<username\\>.github.io/* and directs all routing, replaces assets and everything to this basepath. But we have hosted the **out** folder in **blog/out**, so we must add **subpath** **blog** to the **basepath** to manage assets linking and routing. We can do this by changing the configuration in **next.config.js**\n\n```js:next.config.js\nconst ghPages = process.env.DEPLOY_TARGET === 'gh-pages';\n\nconst withNextOptimizedImages = require('next-optimized-images');\n\nconst withMDX = require('@next/mdx')({\n  extension: /\\.mdx?$/,\n})\n\nmodule.exports = withNextOptimizedImages(\n\twithMDX({\n\t\twebpack: (config, { isServer }) => {\n\t\t\tif (!isServer) {\n\t\t  \tconfig.node = {\n\t\t    fs: 'empty'\n\t\t \t\t}\n\t\t\t}\n\t\t\treturn config\n\t\t},\n\t  pageExtensions: ['js', 'jsx', 'mdx'],\n\t  target: 'serverless',\n\t\tbasePath: ghPages? '/blog/' : '',\n\t\tassetPrefix: ghPages ? '/blog/' : '',\n\t})\n)\n```\n\nWhile developing it works fine everything, so we check the environment phase we are processing with **process.env** and **process.env.DEPLOY_TARGET** tells the current hosted environment. In local development, we run on the **node** server hosted on our machine so we don't need to manage any **basepath** or **subpath**. \n\n**basePath** specifies the base path of the application to manage linking pages. If we are on the **gh-pages**, the base path **/blog/** resolves to **username.github.io/blog/** where **/** is the home path.\n\n**assetPrefix** specifies where to look for assets (CSS, Images, etc.,).\n\n---\n\nAnd here we are with our personal blog on the internet and we can take our blog to next level by adding fancy CSS, custom components, and other pages like **about**, **contact**... Only sky is the limit for human creativity and I hope you will create your website better than mine. In the end, I hope you got some useful information from this article to build your own blog. If you are curious to check the source code of this website, you can find it on [github.com/santhalakshminarayana/santhalakshminarayana.github.io](https://github.com/santhalakshminarayana/santhalakshminarayana.github.io)."}]},"__N_SSG":true}